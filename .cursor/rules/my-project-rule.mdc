---
description: 
globs: 
alwaysApply: true
---
When you want to save memory. My identity is "baryhuang". You should call me "Bary". You should always use Folder "cursor" on recall and save memory.
You should proactively remember the interaction with me. You should pay a lot of attentions to your dead loop, my frustractions, errors you encountered. You should remember how to avoid such errors in the future.

For the system design related thoughts, refer to the following principles:
```
The SOLID principles and Domain-Driven Design (DDD) are foundational concepts in software engineering that, when applied together, can lead to robust, maintainable, and scalable systems.

SOLID Principles:

SOLID is an acronym representing five key design principles aimed at improving object-oriented software design:

Single Responsibility Principle (SRP): A class should have only one reason to change, meaning it should encapsulate only one responsibility or functionality.

Open-Closed Principle (OCP): Software entities should be open for extension but closed for modification. This encourages the design of modules that allow their behavior to be extended without altering their source code.

Liskov Substitution Principle (LSP): Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

Interface Segregation Principle (ISP): Clients should not be forced to depend on interfaces they do not use. It's better to have multiple specific interfaces than a single, general-purpose one.

Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules; both should depend on abstractions. This reduces the coupling between components.

Collectively, these principles aim to create systems that are easier to manage, test, and scale over time.

Domain-Driven Design (DDD):

DDD is an approach to software development that emphasizes collaboration between technical and domain experts to model complex software solutions effectively. Key aspects include:

Ubiquitous Language: A shared language developed by both developers and domain experts to ensure clear and consistent communication.

Bounded Contexts: Explicit boundaries within which a particular domain model applies, ensuring clarity and preventing ambiguity in large systems.

Entities and Value Objects: Distinguishing between objects with a unique identity (entities) and those defined solely by their attributes (value objects).

Aggregates: Clusters of related entities and value objects treated as a single unit to ensure data consistency.

Repositories: Abstractions that provide methods for accessing aggregates, typically encapsulating data storage and retrieval.

Integrating SOLID with DDD:

Applying SOLID principles within a DDD framework enhances the design and maintainability of the domain model:

SRP: Ensures that each component or class within the domain model has a single, well-defined responsibility, aligning with the concept of clearly defined entities and value objects in DDD.

OCP: Facilitates the extension of domain behaviors without modifying existing code, supporting the evolution of the domain model as requirements change.

LSP: Maintains the integrity of the domain model by ensuring that subclasses or derived classes uphold the expectations set by their base classes, preserving behavioral consistency.

ISP: Encourages the creation of specific, role-focused interfaces, which aligns with the DDD practice of modeling behaviors that are pertinent to particular contexts or aggregates.

DIP: Promotes the decoupling of high-level domain logic from low-level data access or service implementations, allowing the domain model to remain independent of technical concerns.

By thoughtfully applying SOLID principles within the context of DDD, developers can craft systems that are both flexible in accommodating new features and resilient against the pitfalls of tight coupling and code rigidity.
```

General: - Don't make uneccessary changes unless asked to refactor.

For python code:
You are an expert in Python, FastAPI, scalable API development, and DynamoDB.

### Key Principles
- Write concise, technical responses with accurate Python examples.
- Use **functional and declarative programming patterns**; avoid classes unless absolutely necessary.
- Prefer **iteration and modularization** over code duplication.
- **Develop small, modular components**: Break down your application into small, manageable modules to enhance maintainability and readability. :contentReference[oaicite:0]{index=0}
- Use descriptive variable names with auxiliary verbs (e.g., `is_active`, `has_permission`).
- Follow proper **naming conventions**: use lowercase with underscores (e.g., `routers/user_routes.py`).

### Code Style and Structure

**Backend (Python/FastAPI)**:
- Use `def` for pure functions and `async def` for asynchronous operations.
- **Type Hints**: Use Python type hints for all function signatures. Utilize Pydantic models for input validation.
- **Error Handling**:
  - Handle errors at the beginning of functions with early returns.
  - Use guard clauses and avoid deeply nested if statements.
  - Implement proper logging and custom error types.

### Performance Optimization

**Backend**:
- **Asynchronous Operations**: Minimize blocking I/O operations using async functions.
- **Caching**: Implement caching strategies for frequently accessed data using in-memory stores.
- **Lazy Loading**: Use lazy loading techniques for large datasets and API responses.

### DynamoDB Design Best Practices
- **Primary Key Design**: Use high-cardinality attributes for partition keys to ensure even data distribution and avoid "hot" partitions. :contentReference[oaicite:1]{index=1}
- **Composite Keys**: Utilize composite primary keys (partition key and sort key) to model one-to-many relationships and enable efficient querying. :contentReference[oaicite:2]{index=2}
- **Index Usage**: Minimize the use of secondary indexes. Instead, design efficient partition and sort keys based on access patterns to retrieve items directly without additional indexes. :contentReference[oaicite:3]{index=3}
- **Avoid Scan and Filter**: Avoid using scan operations followed by filtering, as this approach reads all items and then filters them, leading to inefficient performance. Instead, design your data model to allow for query operations that directly retrieve the desired items. :contentReference[oaicite:4]{index=4}

### Project Conventions

**Backend**:
1. Follow **RESTful API design principles**.
2. Utilize **FastAPI’s dependency injection system** for managing state and shared resources.
3. Ensure **CORS** is properly configured for local development.
4. No authentication or authorization is required for users to access the platform.

